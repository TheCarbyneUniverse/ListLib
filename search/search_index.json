{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Home ListLib is a powerful library that wraps regular Luau tables and adds much more functionality to them. Current Luau tables are very limited and don't cover most common use cases such as reversing, slicing, replacing, and operations. My original inspiration was Python's Numpy module, although it is much larger than ListLib. This started off with me practicing OOP, until I started drifting towards creating something I wanted to publish. Report bugs and request features here: Official release post","title":"Home"},{"location":"#home","text":"ListLib is a powerful library that wraps regular Luau tables and adds much more functionality to them. Current Luau tables are very limited and don't cover most common use cases such as reversing, slicing, replacing, and operations. My original inspiration was Python's Numpy module, although it is much larger than ListLib. This started off with me practicing OOP, until I started drifting towards creating something I wanted to publish. Report bugs and request features here: Official release post","title":"Home"},{"location":"1.0.x/","text":"1.0.x This is will be updated with future versions. v[1.0.0] - Feb 10, 2021 Initial release","title":"1.0.x"},{"location":"1.0.x/#10x","text":"This is will be updated with future versions.","title":"1.0.x"},{"location":"1.0.x/#v100-feb-10-2021","text":"Initial release","title":"v[1.0.0] - Feb 10, 2021"},{"location":"dtypes/","text":"DataTypes There are two main datatypes in ListLib: List NumList List s are the more basic between the two because they add a relatively minimal functionality to regular tables such as manipulation (reverse, replace, etc.) and utility (find, slice, etc.). Lists allow values of any datatype. NumList s, as they may imply, are inherited from Lists, but with the added restriction of only numbers. This allows for various mathamatical funtions such as sum, product, min/max, and stats. More datatypes may be added in the future if necessary.","title":"DataTypes"},{"location":"dtypes/#datatypes","text":"There are two main datatypes in ListLib: List NumList List s are the more basic between the two because they add a relatively minimal functionality to regular tables such as manipulation (reverse, replace, etc.) and utility (find, slice, etc.). Lists allow values of any datatype. NumList s, as they may imply, are inherited from Lists, but with the added restriction of only numbers. This allows for various mathamatical funtions such as sum, product, min/max, and stats. More datatypes may be added in the future if necessary.","title":"DataTypes"},{"location":"features/","text":"Features There are certain convinient features beyond the API, which are in the root type of List and is also inherited downwards. These are primarily built on the metamethods available in Luau, so more may be added if possible! Negative Indexing Negative indicies allow you to reference from the end-to-start direction, where -1 denotes the very last element, -2 second to last, etc. local MyNumList = NumList . new ({ 90 , 92 , 94 , 96 , 98 , 100 }) print ( MyNumList [ - 1 ]) --100 Slicing Using calls, just like with functions, you are able to pass the parameters to slice (or get a certain part of) the List or NumList . It takes in up to three parameters: * int lower -- lower bound * int upper = List.Length -- upper bound; default is the end of the list * int step = 1 -- incremend the indexing; default is 1 (consecutive elements) Additionally, you are able to input negative numbers! local MyNumList = NumList . fromRange ( 1 , 25 ) print ( MyNumList ( - 15 , - 1 , 2 )) --NumList({11, 13, 15, 17, 19, 21, 23, 25}) --or reverse the list using negative step! print ( MyNumList ( - 15 , - 1 , - 2 )) --NumList({25, 23, 21, 19, 17, 15, 13, 11}) Concatenation Merge two List s or NumList s together on the stop using the concatenation operator. local MyList1 = List . new ({ 1 , \"two\" , 3 }) local MyList2 = List . new ({ \"four\" , 5 , 6 }) print ( MyList1 .. MyList2 ) --NumList({1, \"two\", 3, \"four\", 5, 6}) MyList2 ..= MyList1 print ( MyList2 ) --NumList({\"four\", 5, 6, 1, \"two\", 3}) Comparisons With List s and NumList s, you can check the equality of any two of them: local MyList1 = List . new ({ \"one\" , \"two\" , 3 }) local MyList2 = List . new ({ 4 , 5 , \"six\" }) print ( MyList1 == MyList2 ) --false MyList1 = MyList2 : Clone () print ( MyList1 == MyList2 ) --true With NumList s specifically, the sums of the two will be calculated and compared: local MyNumList1 = NumList . new ({ 58 , 10 , 9 }) local MyNumList2 = NumList . new ({ 10 , 9 , 2 }) print ( MyNumList1 > MyNumList2 ) --true print ( MyNumList1 >= MyNumList2 ) --true print ( MyNumList1 < MyNumList2 ) --false print ( MyNumList1 <= MyNumList2 ) --false In the future, there may be an option to choose your \"compairson metric\" between sum, average, min, max, etc.! Operations With NumList s, you are able to add, subtract, multiply, divide, mod, and exponentiate them with a number or another table/ NumList of an equal length . local MyNumList = NumList . fromRange ( 1 , 5 ) print ( MyNumList + 2 ) --NumList({3, 4, 5, 6, 7}) print ( MyNumList * { 2 , 3 , 4 , 5 , 6 }) --NumList({2, 6, 12, 20, 30}) print ( MyNumList / { 1 , 2 }) --error (not equal length) Raising Errors ListLib tries its best to catch errors with parameters and arguments, so you are able to fix the issue without having to sort through the internal code. Usually it's in the format of: [action]: [reason] For example, for slicing a NumList , if you input non-intengers as the input, you may see: slicing: inputs must be integers Additionally, the output should also show the line numbers of your script and not the internal module scripts, although in certain cases with 2+ stacks, this can point to internal code.","title":"More Features"},{"location":"features/#features","text":"There are certain convinient features beyond the API, which are in the root type of List and is also inherited downwards. These are primarily built on the metamethods available in Luau, so more may be added if possible!","title":"Features"},{"location":"features/#negative-indexing","text":"Negative indicies allow you to reference from the end-to-start direction, where -1 denotes the very last element, -2 second to last, etc. local MyNumList = NumList . new ({ 90 , 92 , 94 , 96 , 98 , 100 }) print ( MyNumList [ - 1 ]) --100","title":"Negative Indexing"},{"location":"features/#slicing","text":"Using calls, just like with functions, you are able to pass the parameters to slice (or get a certain part of) the List or NumList . It takes in up to three parameters: * int lower -- lower bound * int upper = List.Length -- upper bound; default is the end of the list * int step = 1 -- incremend the indexing; default is 1 (consecutive elements) Additionally, you are able to input negative numbers! local MyNumList = NumList . fromRange ( 1 , 25 ) print ( MyNumList ( - 15 , - 1 , 2 )) --NumList({11, 13, 15, 17, 19, 21, 23, 25}) --or reverse the list using negative step! print ( MyNumList ( - 15 , - 1 , - 2 )) --NumList({25, 23, 21, 19, 17, 15, 13, 11})","title":"Slicing"},{"location":"features/#concatenation","text":"Merge two List s or NumList s together on the stop using the concatenation operator. local MyList1 = List . new ({ 1 , \"two\" , 3 }) local MyList2 = List . new ({ \"four\" , 5 , 6 }) print ( MyList1 .. MyList2 ) --NumList({1, \"two\", 3, \"four\", 5, 6}) MyList2 ..= MyList1 print ( MyList2 ) --NumList({\"four\", 5, 6, 1, \"two\", 3})","title":"Concatenation"},{"location":"features/#comparisons","text":"With List s and NumList s, you can check the equality of any two of them: local MyList1 = List . new ({ \"one\" , \"two\" , 3 }) local MyList2 = List . new ({ 4 , 5 , \"six\" }) print ( MyList1 == MyList2 ) --false MyList1 = MyList2 : Clone () print ( MyList1 == MyList2 ) --true With NumList s specifically, the sums of the two will be calculated and compared: local MyNumList1 = NumList . new ({ 58 , 10 , 9 }) local MyNumList2 = NumList . new ({ 10 , 9 , 2 }) print ( MyNumList1 > MyNumList2 ) --true print ( MyNumList1 >= MyNumList2 ) --true print ( MyNumList1 < MyNumList2 ) --false print ( MyNumList1 <= MyNumList2 ) --false In the future, there may be an option to choose your \"compairson metric\" between sum, average, min, max, etc.!","title":"Comparisons"},{"location":"features/#operations","text":"With NumList s, you are able to add, subtract, multiply, divide, mod, and exponentiate them with a number or another table/ NumList of an equal length . local MyNumList = NumList . fromRange ( 1 , 5 ) print ( MyNumList + 2 ) --NumList({3, 4, 5, 6, 7}) print ( MyNumList * { 2 , 3 , 4 , 5 , 6 }) --NumList({2, 6, 12, 20, 30}) print ( MyNumList / { 1 , 2 }) --error (not equal length)","title":"Operations"},{"location":"features/#raising-errors","text":"ListLib tries its best to catch errors with parameters and arguments, so you are able to fix the issue without having to sort through the internal code. Usually it's in the format of: [action]: [reason] For example, for slicing a NumList , if you input non-intengers as the input, you may see: slicing: inputs must be integers Additionally, the output should also show the line numbers of your script and not the internal module scripts, although in certain cases with 2+ stacks, this can point to internal code.","title":"Raising Errors"},{"location":"import/","text":"Importing The structure for ListLib is as follows: ListLib List NumList To easily load all the modules, you can require the base ListLib module which returns a function to import the other two: local import = require ( ListLib ) local List , NumList = import ( \"List\" , \"NumList\" ) The importation will return the module functionality in the order of parameters. Importing vs Requiring It is highly recommended that you use the import function because it will initialize that script's environment with updated in-built functions such as pairs , type , typeof , etc. to recognize these datatypes and treat them accordingly. In scripts that you pass the objects as parameters, for example, and ListLib isn't be imported, the script environments will not be updated with these functions, so you must be the functions within the object itself such as List:Pairs and List.__type (for the above three).","title":"Importing"},{"location":"import/#importing","text":"The structure for ListLib is as follows: ListLib List NumList To easily load all the modules, you can require the base ListLib module which returns a function to import the other two: local import = require ( ListLib ) local List , NumList = import ( \"List\" , \"NumList\" ) The importation will return the module functionality in the order of parameters. Importing vs Requiring It is highly recommended that you use the import function because it will initialize that script's environment with updated in-built functions such as pairs , type , typeof , etc. to recognize these datatypes and treat them accordingly. In scripts that you pass the objects as parameters, for example, and ListLib isn't be imported, the script environments will not be updated with these functions, so you must be the functions within the object itself such as List:Pairs and List.__type (for the above three).","title":"Importing"},{"location":"installation/","text":"Installation Method 1: Roblox Model Get the model from the website. In Roblox Studio, open the toolbar and go to My Models tab. Find the ListLib model, then click to insert or drag to your desired location. Method 2: RBXM File Go to ListLib's releases page and locate the latest version Under Assets , download ListLib.rbxm . In Roblox Studio, right click your desired location (i.e. ReplicatedStorage ), click Insert from file and choose the downloaded file. Method 3: Rojo Go to the ListLib repository . Click Fork in the top right and clone this to your own repository. Modify the default.project.json file to your desired location (ListLib uses ServerStorage by default). Take the src folder and put it into your project, the rest are unnecessary. Start Rojo to sync with its Studio plugin counterpart.","title":"Installation"},{"location":"installation/#installation","text":"","title":"Installation"},{"location":"installation/#method-1-roblox-model","text":"Get the model from the website. In Roblox Studio, open the toolbar and go to My Models tab. Find the ListLib model, then click to insert or drag to your desired location.","title":"Method 1: Roblox Model"},{"location":"installation/#method-2-rbxm-file","text":"Go to ListLib's releases page and locate the latest version Under Assets , download ListLib.rbxm . In Roblox Studio, right click your desired location (i.e. ReplicatedStorage ), click Insert from file and choose the downloaded file.","title":"Method 2: RBXM File"},{"location":"installation/#method-3-rojo","text":"Go to the ListLib repository . Click Fork in the top right and clone this to your own repository. Modify the default.project.json file to your desired location (ListLib uses ServerStorage by default). Take the src folder and put it into your project, the rest are unnecessary. Start Rojo to sync with its Studio plugin counterpart.","title":"Method 3: Rojo"},{"location":"list/","text":"List API Reference A List is essentially an ordered array with added functionalities. As with normal arrays, the indices must be numbers, but the values can be anything. Note This only shows the API that is for consumer use; hidden API is not listed. If you plan on dealing with only numerical values, then consider using NumLists instead, which have specialized mathematical and calculative functions. Class Properties These properties apply to every object of the class. Inline boolean If true, the List will display in a single-line and will wrap depending on the output window. If false, each element will drop to a new line--this is perfect for long datatypes such as CFrame, which would look like a mess if all in one-line: --above example --default Inline = true print ( MyList ) --List({Vector3[], ColorSequenceKeypoint[], CatalogSearchParams[]}) List . Inline = false print ( MyList ) --[[ List({Vector3[], ColorSequenceKeypoint[], CatalogSearchParams[]}) ]] MaxDisplay int Denotes the maximum number of elements to fully show when printing before it condenses into a a, b, c...x, y, z structure. local chars = {} for i = 97 , 113 do table.insert ( chars , string.char ( i )) -- chars from a-q end local MyList = List . new ( chars ) --defualt MaxDisplay = 10 print ( MyList ) --List({a, b, c...o, p, q}) List . MaxDisplay = 100 print ( MyList ) --List({a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q}) ShowDataTypeContents boolean If true, the List will show the parameters inside of the datatypes within (such as CFrame , Vector3 , etc.), else it will appear blank: local MyList = List . new ({ Vector3 . new ( 15 , 25 , 35 ), ColorSequenceKeypoint . new ( 0.5 , Color3 . new ( 1 , 1 , 1 )), CatalogSearchParams . new () }) --default ShowDataTypeContents = false print ( MyList ) --List({Vector3[], ColorSequenceKeypoint[], CatalogSearchParams[]}) List . ShowDataTypeContents = true print ( MyList ) --List({Vector3[15, 25, 35], ColorSequenceKeypoint[0.5, (1, 1, 1)], CatalogSearchParams[\"\", 0-2147483647, Relevance, None, {...}, {...}]}) Constructors new Parameters ( table array) Creates a List from the given array. --this is the List we will use for future examples local MyList = List . new ({ 1 , true , \"three\" , 4 , 5 }) print ( MyList ) --List({1, true, three, 4, 5}) fillWith Parameters ( int count, variant value) Essentially table.create ; creates a array of count number of value s. local MyList = List . fillWith ( 5 , 'a' ) print ( MyList ) --List({'a', 'a', 'a', 'a', 'a'}) Properties Alias string Used to \"name\" the List, which shows when printing. This can be useful for distinguishing between different Lists. MyList . Alias = \"Example\" print ( MyList ) --Example({1, true, three, 4, 5}) Length number READONLY The length of the List. Simply doing #List will always return 0 because the object will be a proxy (empty) table. print ( # MyList ) --0 print ( MyList . Length ) --5 __type string READONLY Signifies the type of the object, which will always be List . Alternatively, you can also get the type via type(MyList) or typeof(MyList) , but only in scripts that require the base module directly. That is, if you pass the object as a parameter to another script, you must use __type because type and typeof will always return table in those environments. --script that requires module local import = require ( ListLibModule ) --this does the magic! local List = import ( 'List' ) print ( typeof ( MyList )) --List print ( type ( MyList )) --List print ( MyList . __type ) --List --in another script that does NOT require the ListLib module print ( typeof ( MyList )) --table print ( type ( MyList )) --table print ( MyList . __type ) --List Functions AddFunction void Parameters ( string name, function func) Creates a custom method for that List object with the given name and func . When calling, any parameters passed can be recieved by the given func . Speaking of calling, you can call using both . and : ; in the latter, func 's first parameter will always be self , in the former, this will not happen. --our function here will get the first and last element from the list MyList : AddFunction ( 'GetEnds' , function ( self , ...) print (...) --just demonstration purposes return self [ 1 ], self [ self . Length ] end ) local first , last = MyList : GetEnds ( 'random' , 'args' ) --prints: random, args print ( first , last ) --1 5 Similarily, if you don't anticipate using self , then you always use . (e.g. MyList.SomeFunction() ). AddProperty void Parameters ( string name, variant value) Creates a custom property with name name and a default value of value , which can be anything but a function (for that use List:AddFunction ). Using List:AddFunction and List:AddProperty --this basically checks if the \"owner\" of the list is a certain username, which will --control how the custom method will behave (it's pointless; just demonstration purposes) MyList : AddProperty ( 'Owner' , 'TheCarbyneUniverse' ) MyList : AddFunction ( 'IsStolen' , function ( self ) return not self . Owner == 'TheCarbyneUniverse' end ) print ( MyList : IsStolen ()) --false MyList . Owner = 'coefficients' print ( MyList : IsStolen ()) --true Append void Parameters ( variant item, ...) An inplace method; allows the addition of at least one item at the end of the List: MyList : Append ( 6 , 7 , \"eight\" ) print ( MyList ) --MyList({1, true, three, 4, 5, 6, 7, \"eight\"}) Clear void Just like table.clear ; it empties the internal table, but leaves the memory allocated for future need. Clone List Creates an identical List , similar to Instance:Clone . Count number Parameters ( variante value) Returns the number times value appears in the List: local MyNewList = List . new ({ \"hello\" , \"world\" , 2 , \"hello\" }) print ( MyNewList : Count ( \"hello\" )) --2 CountValues table Returns a table with the count of all the values in the table, arranged in descending order. The structure is as follows: {{value, count}, {value, count}, ... {value, count}} local MyNewList = List . new ({ true , false , true , true , 1 , 2 , 2 , 3 }) print ( MyNewList : CountValues ()) --[[ { {true, 3}, {2, 2}, {false, 1}, {1, 1}, {3, 1} } ]] This way, you can get the most numerous value like such: print ( MyNewList : CountValues ()[ 1 ][ 1 ]) --true Destroy void Destroys the List object, empties the internal table, and sets every functionality unaccessible. print ( MyList [ 1 ]) --1 MyList : Destroy () print ( MyList [ 1 ]) --nil print ( MyList : Append ( 2 )) --error Empty void Empties the internal table and unallocates the memory, unlike List:Clear . Find number or table Parameters ( variant item, boolean all = false) Finds the first occurence of item and returns the index. If all is true, then returns a table of indices of all occurences. local MyNewList = List . new ({ 1 , 2 , 3 , 2 }) print ( MyNewList : Find ( 2 )) --2 print ( MyNewList : Find ( 2 , true )) --{2, 4} GetTable table Basically gets table version of the List, which can be useful when you want to end List functionalities and access table functionalities. Pairs function Returns an iterator function and behaves just like Lua pairs . If the script you're using does not require the base ListLib module, then you must use this function instead of just doing pairs(List) : --script that requires ListLib for i , v in pairs ( MyList ) do print ( i , v ) end --script that does NOT require ListLib for i , v in MyList : Pairs () do print ( i , v ) end Remove void Parameters ( variant item, number startingIndex = 1, number count = 1) An inplace method; removes item from the List, and behaves like table.remove . On top of that, if startingIndex is given, it will remove count number of occurrences of item . To input count , you must provide startingIndex first. Unlike List:Append , you can only input one item at a time. Tip You can input -1 as count to remove all occurrences! local MyNewList = List . new ({ \"string\" , \"anotherStr\" , \"string\" , \"somethingElse\" , \"string\" }) MyNewList : Remove ( \"string\" , 2 , - 1 ) print ( MyNewList ) --List({string, anotherStr, somethingElse}) The above examle ignored the \"string\" at index 1 because the given startIndex was 2. RemoveDuplicates void Parameters ( variant item) An inplace method; removes duplicates of item . Alternatively, you can manually do: --starts from the index after the index of \"value\" and clears all occurences from then on MyList : Remove ( \"value\" , MyList : Find ( \"value\" ) + 1 , - 1 ) Replace void Parameters ( variant item, variant newItem, number startingIndex = 1, number count = 1) An inplace method; replaces the first occurrence of item with newItem . If startingIndex is given, the replacement will start from that index onwards. If count is given, replaces that many occurrences of item . Tip You can input -1 as count to replace all occurrences! Reverse List or void Parameters ( boolean inplace = false) Reverses the List, and if inplace is true, the method acts like an inplace method, otherwise, the reversed List is returned. MyList : Reverse ( true ) print ( MyList ) --or print ( MyList : Reverse ()) --both give: --List({5, 4, three, true, 1}) Shuffle List or void Parameters ( boolean inplace = false) Shuffles the List randomly; if inplace is true, the current List is replaced, otherwise, the shuffled List will be returned. Sort List or void Parameters ( boolean descending = false, boolean inplace = false) By default, sorts the List in ascending ordeer unless descending is true. If inplace is true, the current List is sorted, otherwise, the current List will not be affected and the sorted List will be returned. Regarding Sorting The method uses table.sort internally, so non-numerical values will be sorted with the mercy of the aforementioned function! For example, strings will be in alphabetical order, but mixed Lists will be grouped by datatypes according to how table.sort would do it. Unpack void Unpacks the list similar to table.unpack . Zip function Parameters ( variant iterable, ...) An iterator function that works like Python's zip . You can give as many iterable objects as needed, such as strings , tables , Lists , NumLists , or Matricies . Each iterable will be indexed in order and the function returns the corresponding element from each. local someTable = { 5 , 4 , 3 , 2 , 1 , 0 } local str = \"hello\" local MyList = List . new ({ 1 , true , three , 4 , 5 , 6 , 7 , eight }) for i , v1 , v2 , v3 in MyList : Zip ( someTable , str ) do print ( i , v1 , v2 , v3 ) end --[[output: 1 1 5 h 2 true 4 e 3 three 3 l 4 4 2 l 5 5 1 o ]] Here's what happening above: Index Value1 Value2 Value3 1 1 5 h 2 true 4 e 3 three 3 l 4 4 2 l 5 5 1 o Info Zipping will end when the end the of the shortest iterable is reached. In the above example, since the string str was the shortest out of the three with the length of 5, the zipping stopped at index 5. If the above kept on going until the end of the longest iterable , it would look like this: Index Value1 Value2 Value3 6 6 0 nil 7 7 nil nil 8 eight nil nil Events The following events will only fire when the actual List elements are altered, not when a property or function is. That is, doing List.Alias = 'something' will not fire, but doing List[1] = 2 will. Added Parameters ( number index, variant value) Every time a new index is made, the event fires with that new index and the value . MyList . Added : Connect ( function ( i , v ) print ( 'index added:' , i , ' \\n value added:' , v ) end ) Changed Parameters ( number index, variant oldValue, variant newValue) When you alter an existing index, the event fires with that index , the original oldValue , and the replacing newValue . Using List:Append will run this event sequentially with the order of the arguments. Note: the event will only fire if newValue is not equal to oldValue . MyList . Changed : Connect ( function ( i , vOld , vNew ) print ( 'index changed:' , i , ' \\n old value:' , vOld , ' \\n new value:' , vNew ) end ) Removed Parameters ( number index, variant value) When an existing index is removed (either by setting to nil or List:Remove ), the event fires with the index and value , both of each will be removed. MyList . Removed : Connect ( function ( i , v ) print ( 'index removed:' , i , ' \\n value removed:' , v ) end )","title":"List"},{"location":"list/#list","text":"API Reference A List is essentially an ordered array with added functionalities. As with normal arrays, the indices must be numbers, but the values can be anything. Note This only shows the API that is for consumer use; hidden API is not listed. If you plan on dealing with only numerical values, then consider using NumLists instead, which have specialized mathematical and calculative functions.","title":"List"},{"location":"list/#class-properties","text":"These properties apply to every object of the class.","title":"Class Properties"},{"location":"list/#inline","text":"boolean If true, the List will display in a single-line and will wrap depending on the output window. If false, each element will drop to a new line--this is perfect for long datatypes such as CFrame, which would look like a mess if all in one-line: --above example --default Inline = true print ( MyList ) --List({Vector3[], ColorSequenceKeypoint[], CatalogSearchParams[]}) List . Inline = false print ( MyList ) --[[ List({Vector3[], ColorSequenceKeypoint[], CatalogSearchParams[]}) ]]","title":"Inline"},{"location":"list/#maxdisplay","text":"int Denotes the maximum number of elements to fully show when printing before it condenses into a a, b, c...x, y, z structure. local chars = {} for i = 97 , 113 do table.insert ( chars , string.char ( i )) -- chars from a-q end local MyList = List . new ( chars ) --defualt MaxDisplay = 10 print ( MyList ) --List({a, b, c...o, p, q}) List . MaxDisplay = 100 print ( MyList ) --List({a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q})","title":"MaxDisplay"},{"location":"list/#showdatatypecontents","text":"boolean If true, the List will show the parameters inside of the datatypes within (such as CFrame , Vector3 , etc.), else it will appear blank: local MyList = List . new ({ Vector3 . new ( 15 , 25 , 35 ), ColorSequenceKeypoint . new ( 0.5 , Color3 . new ( 1 , 1 , 1 )), CatalogSearchParams . new () }) --default ShowDataTypeContents = false print ( MyList ) --List({Vector3[], ColorSequenceKeypoint[], CatalogSearchParams[]}) List . ShowDataTypeContents = true print ( MyList ) --List({Vector3[15, 25, 35], ColorSequenceKeypoint[0.5, (1, 1, 1)], CatalogSearchParams[\"\", 0-2147483647, Relevance, None, {...}, {...}]})","title":"ShowDataTypeContents"},{"location":"list/#constructors","text":"","title":"Constructors"},{"location":"list/#new","text":"Parameters ( table array) Creates a List from the given array. --this is the List we will use for future examples local MyList = List . new ({ 1 , true , \"three\" , 4 , 5 }) print ( MyList ) --List({1, true, three, 4, 5})","title":"new"},{"location":"list/#fillwith","text":"Parameters ( int count, variant value) Essentially table.create ; creates a array of count number of value s. local MyList = List . fillWith ( 5 , 'a' ) print ( MyList ) --List({'a', 'a', 'a', 'a', 'a'})","title":"fillWith"},{"location":"list/#properties","text":"","title":"Properties"},{"location":"list/#alias","text":"string Used to \"name\" the List, which shows when printing. This can be useful for distinguishing between different Lists. MyList . Alias = \"Example\" print ( MyList ) --Example({1, true, three, 4, 5})","title":"Alias"},{"location":"list/#length","text":"number READONLY The length of the List. Simply doing #List will always return 0 because the object will be a proxy (empty) table. print ( # MyList ) --0 print ( MyList . Length ) --5","title":"Length"},{"location":"list/#__type","text":"string READONLY Signifies the type of the object, which will always be List . Alternatively, you can also get the type via type(MyList) or typeof(MyList) , but only in scripts that require the base module directly. That is, if you pass the object as a parameter to another script, you must use __type because type and typeof will always return table in those environments. --script that requires module local import = require ( ListLibModule ) --this does the magic! local List = import ( 'List' ) print ( typeof ( MyList )) --List print ( type ( MyList )) --List print ( MyList . __type ) --List --in another script that does NOT require the ListLib module print ( typeof ( MyList )) --table print ( type ( MyList )) --table print ( MyList . __type ) --List","title":"__type"},{"location":"list/#functions","text":"","title":"Functions"},{"location":"list/#addfunction","text":"void Parameters ( string name, function func) Creates a custom method for that List object with the given name and func . When calling, any parameters passed can be recieved by the given func . Speaking of calling, you can call using both . and : ; in the latter, func 's first parameter will always be self , in the former, this will not happen. --our function here will get the first and last element from the list MyList : AddFunction ( 'GetEnds' , function ( self , ...) print (...) --just demonstration purposes return self [ 1 ], self [ self . Length ] end ) local first , last = MyList : GetEnds ( 'random' , 'args' ) --prints: random, args print ( first , last ) --1 5 Similarily, if you don't anticipate using self , then you always use . (e.g. MyList.SomeFunction() ).","title":"AddFunction"},{"location":"list/#addproperty","text":"void Parameters ( string name, variant value) Creates a custom property with name name and a default value of value , which can be anything but a function (for that use List:AddFunction ). Using List:AddFunction and List:AddProperty --this basically checks if the \"owner\" of the list is a certain username, which will --control how the custom method will behave (it's pointless; just demonstration purposes) MyList : AddProperty ( 'Owner' , 'TheCarbyneUniverse' ) MyList : AddFunction ( 'IsStolen' , function ( self ) return not self . Owner == 'TheCarbyneUniverse' end ) print ( MyList : IsStolen ()) --false MyList . Owner = 'coefficients' print ( MyList : IsStolen ()) --true","title":"AddProperty"},{"location":"list/#append","text":"void Parameters ( variant item, ...) An inplace method; allows the addition of at least one item at the end of the List: MyList : Append ( 6 , 7 , \"eight\" ) print ( MyList ) --MyList({1, true, three, 4, 5, 6, 7, \"eight\"})","title":"Append"},{"location":"list/#clear","text":"void Just like table.clear ; it empties the internal table, but leaves the memory allocated for future need.","title":"Clear"},{"location":"list/#clone","text":"List Creates an identical List , similar to Instance:Clone .","title":"Clone"},{"location":"list/#count","text":"number Parameters ( variante value) Returns the number times value appears in the List: local MyNewList = List . new ({ \"hello\" , \"world\" , 2 , \"hello\" }) print ( MyNewList : Count ( \"hello\" )) --2","title":"Count"},{"location":"list/#countvalues","text":"table Returns a table with the count of all the values in the table, arranged in descending order. The structure is as follows: {{value, count}, {value, count}, ... {value, count}} local MyNewList = List . new ({ true , false , true , true , 1 , 2 , 2 , 3 }) print ( MyNewList : CountValues ()) --[[ { {true, 3}, {2, 2}, {false, 1}, {1, 1}, {3, 1} } ]] This way, you can get the most numerous value like such: print ( MyNewList : CountValues ()[ 1 ][ 1 ]) --true","title":"CountValues"},{"location":"list/#destroy","text":"void Destroys the List object, empties the internal table, and sets every functionality unaccessible. print ( MyList [ 1 ]) --1 MyList : Destroy () print ( MyList [ 1 ]) --nil print ( MyList : Append ( 2 )) --error","title":"Destroy"},{"location":"list/#empty","text":"void Empties the internal table and unallocates the memory, unlike List:Clear .","title":"Empty"},{"location":"list/#find","text":"number or table Parameters ( variant item, boolean all = false) Finds the first occurence of item and returns the index. If all is true, then returns a table of indices of all occurences. local MyNewList = List . new ({ 1 , 2 , 3 , 2 }) print ( MyNewList : Find ( 2 )) --2 print ( MyNewList : Find ( 2 , true )) --{2, 4}","title":"Find"},{"location":"list/#gettable","text":"table Basically gets table version of the List, which can be useful when you want to end List functionalities and access table functionalities.","title":"GetTable"},{"location":"list/#pairs","text":"function Returns an iterator function and behaves just like Lua pairs . If the script you're using does not require the base ListLib module, then you must use this function instead of just doing pairs(List) : --script that requires ListLib for i , v in pairs ( MyList ) do print ( i , v ) end --script that does NOT require ListLib for i , v in MyList : Pairs () do print ( i , v ) end","title":"Pairs"},{"location":"list/#remove","text":"void Parameters ( variant item, number startingIndex = 1, number count = 1) An inplace method; removes item from the List, and behaves like table.remove . On top of that, if startingIndex is given, it will remove count number of occurrences of item . To input count , you must provide startingIndex first. Unlike List:Append , you can only input one item at a time. Tip You can input -1 as count to remove all occurrences! local MyNewList = List . new ({ \"string\" , \"anotherStr\" , \"string\" , \"somethingElse\" , \"string\" }) MyNewList : Remove ( \"string\" , 2 , - 1 ) print ( MyNewList ) --List({string, anotherStr, somethingElse}) The above examle ignored the \"string\" at index 1 because the given startIndex was 2.","title":"Remove"},{"location":"list/#removeduplicates","text":"void Parameters ( variant item) An inplace method; removes duplicates of item . Alternatively, you can manually do: --starts from the index after the index of \"value\" and clears all occurences from then on MyList : Remove ( \"value\" , MyList : Find ( \"value\" ) + 1 , - 1 )","title":"RemoveDuplicates"},{"location":"list/#replace","text":"void Parameters ( variant item, variant newItem, number startingIndex = 1, number count = 1) An inplace method; replaces the first occurrence of item with newItem . If startingIndex is given, the replacement will start from that index onwards. If count is given, replaces that many occurrences of item . Tip You can input -1 as count to replace all occurrences!","title":"Replace"},{"location":"list/#reverse","text":"List or void Parameters ( boolean inplace = false) Reverses the List, and if inplace is true, the method acts like an inplace method, otherwise, the reversed List is returned. MyList : Reverse ( true ) print ( MyList ) --or print ( MyList : Reverse ()) --both give: --List({5, 4, three, true, 1})","title":"Reverse"},{"location":"list/#shuffle","text":"List or void Parameters ( boolean inplace = false) Shuffles the List randomly; if inplace is true, the current List is replaced, otherwise, the shuffled List will be returned.","title":"Shuffle"},{"location":"list/#sort","text":"List or void Parameters ( boolean descending = false, boolean inplace = false) By default, sorts the List in ascending ordeer unless descending is true. If inplace is true, the current List is sorted, otherwise, the current List will not be affected and the sorted List will be returned. Regarding Sorting The method uses table.sort internally, so non-numerical values will be sorted with the mercy of the aforementioned function! For example, strings will be in alphabetical order, but mixed Lists will be grouped by datatypes according to how table.sort would do it.","title":"Sort"},{"location":"list/#unpack","text":"void Unpacks the list similar to table.unpack .","title":"Unpack"},{"location":"list/#zip","text":"function Parameters ( variant iterable, ...) An iterator function that works like Python's zip . You can give as many iterable objects as needed, such as strings , tables , Lists , NumLists , or Matricies . Each iterable will be indexed in order and the function returns the corresponding element from each. local someTable = { 5 , 4 , 3 , 2 , 1 , 0 } local str = \"hello\" local MyList = List . new ({ 1 , true , three , 4 , 5 , 6 , 7 , eight }) for i , v1 , v2 , v3 in MyList : Zip ( someTable , str ) do print ( i , v1 , v2 , v3 ) end --[[output: 1 1 5 h 2 true 4 e 3 three 3 l 4 4 2 l 5 5 1 o ]] Here's what happening above: Index Value1 Value2 Value3 1 1 5 h 2 true 4 e 3 three 3 l 4 4 2 l 5 5 1 o Info Zipping will end when the end the of the shortest iterable is reached. In the above example, since the string str was the shortest out of the three with the length of 5, the zipping stopped at index 5. If the above kept on going until the end of the longest iterable , it would look like this: Index Value1 Value2 Value3 6 6 0 nil 7 7 nil nil 8 eight nil nil","title":"Zip"},{"location":"list/#events","text":"The following events will only fire when the actual List elements are altered, not when a property or function is. That is, doing List.Alias = 'something' will not fire, but doing List[1] = 2 will.","title":"Events"},{"location":"list/#added","text":"Parameters ( number index, variant value) Every time a new index is made, the event fires with that new index and the value . MyList . Added : Connect ( function ( i , v ) print ( 'index added:' , i , ' \\n value added:' , v ) end )","title":"Added"},{"location":"list/#changed","text":"Parameters ( number index, variant oldValue, variant newValue) When you alter an existing index, the event fires with that index , the original oldValue , and the replacing newValue . Using List:Append will run this event sequentially with the order of the arguments. Note: the event will only fire if newValue is not equal to oldValue . MyList . Changed : Connect ( function ( i , vOld , vNew ) print ( 'index changed:' , i , ' \\n old value:' , vOld , ' \\n new value:' , vNew ) end )","title":"Changed"},{"location":"list/#removed","text":"Parameters ( number index, variant value) When an existing index is removed (either by setting to nil or List:Remove ), the event fires with the index and value , both of each will be removed. MyList . Removed : Connect ( function ( i , v ) print ( 'index removed:' , i , ' \\n value removed:' , v ) end )","title":"Removed"},{"location":"numlist/","text":"NumList API Reference NumList s are List s that are specialized for numbers. It inherits the methods and properties from List , but has certain added on top. The datatype supports a number base system upon creation and conversion up to hexadecimal. Note This only shows the API that is for consumer use; hidden API is not listed. Class Properties Inherited from List Inline MaxDisplay ShowDataTypeContents is not inherited since the only datatype supported is numbers. Constructors new Parameters ( table array, int base = 10) Creates a new NumList with the given array (filled with numbers only) and an optional base , which defaults to 10. For other bases, use strings in the array to preserve their numerical representation. If the strings are invalid (i.e. higher than base 16 or plain words), NumList will rasie an error something along the lines of NumList creation: an error occurred . However, despite the base given, the numbers will always be converted to base 10. --we will use this for future examples --binary inputs local MyNumList = NumList . new ({ '1010' , '1001' , '1000' , '0111' , '0110' , '0101' }, 2 ) --must include 2, else it will error! print ( MyNumList ) --NumList({10, 9, 8, 7, 6, 5}) fromNormal Parameters ( int count, number avg, number std) Creates a normalized distribution with count number of values and with the given mean of avg and standard deviation of std . Note Due to floating point errors that may occasionally arise, the average and standard deviation may be ever-so-slightly off (i.e. something like 5.0000000012 instead of 5 ). fillWith Parameters ( int count, number value) Works just like List.fillWith except that the values must always be numerical. fromRandom Parameters ( number min, number max, int count) Creates count number of elements which are random numbers between the given min and max , which can be decimals. local MyNumList = NumList . fromRandom ( 0.1 , 0.55 , 5 ) print ( MyNumList ) --NumList({0.41, 0.18, 0.5, 0.44, 0.45}) fromRange Parameters ( number min, number max, number step = 1, int base = 10) Similar to Python's numpy.arange ; creates an array from min to max , incrementing by the optional step . The inputs for those three can be given in strings in case they are non-base 10 numbers. --array from 90-100 with inc 2 in the hexadecimal number system local MyNumList = NumList . fromRange ( '5A' , '64' , '2' , 16 ) print ( MyNumList ) --NumList({90, 92, 94, 96, 98, 100}) linspace Parameters ( number min, number max, int count) Just like numpy.linspace ; it creates an array from min to max with the given count such that each number is spaced out by an event, automatically-calculated increment (unlike NumList.fromRange ). local MyNumList = NumList . linspace ( 1 , 10 , 5 ) print ( MyNumList ) --NumList({1, 3.25, 5.5, 7.75, 10}) Above, the increment is 2.25 (which can be calculated by (max - min) / (count - 1) ). Properties Inherited from List These properties are inherited from List and work the same way: Alias Length __type Functions GetAvg number Gets the average of the numbers, equivalent to doing NumList:GetSum() / NumList.Length . GetFivePointSummary table Gets the box-plot-related stats (minimum, first quartile, median, third quartile, and maximum) in a dictionary with the keys: * Min * Q1 * Median * Q3 * Max GetMAD number Gets the mean absolute deviation of the NumList ; the length must be greater than 0, else an error will be raised. GetMax number Gets the maximum value from the NumList . GetMedian number Gets the median of the NumList . GetMin number Gets the minimum value from the NumList . GetMode table Gets the mode of the set and returns the values in a table (since multiple values can appear the same number of times). If every value appears exactly once in the set, the mode will be nil . GetProduct number Simply gets the product of all the elements in the NumList . GetQ1 number Gets the first quartile of the set. GetQ3 number Gets the third quartile of the set. GetRange number Gets the range, the difference between the maximum and the minimum. GetStats table Gets all the stats in a dictionary, with the keys: Min Q1 Median Q3 Max Range Sum Product Avg Std MAD Mode For Mode , the value will be \"None\" to represent nil because else the key will be non-existent. GetStd number Gets the population standard deviation of the set of numbers; the length of the NumList must be greater than 1, else it will raise an error. GetSum number Simply gets the sum of all the elements in the NumList . ToBase table Parameters ( int base) Converts the current base-10 NumList values to the given base , which will be returned as a table ( not a NumList) with string values. Also works with decimals. local MyNumList = NumList . new ({ 90 , 92 , 94 , 96 , 98 , 100 }) print ( MyNumList : ToBase ( 16 )) --{\"5A\", \"5C\", \"5E\", \"60\", \"62\", \"64\"} Inherited from List These functions are inherited from List and are also available with NumList (only with slight modifications to accept only numbers, for example): NumList:Append NumList:Clear NumList:Clone NumList:Count NumList:CountValues NumList:Destroy NumList:Empty NumList:Find NumList:Pairs NumList:Remove NumList:RemoveDuplicates NumList:Replace NumList:Reverse NumList:Select NumList:Sort NumList:Zip Events Inherited from List These events work the same as they do with List : Added Changed Removed","title":"NumList"},{"location":"numlist/#numlist","text":"API Reference NumList s are List s that are specialized for numbers. It inherits the methods and properties from List , but has certain added on top. The datatype supports a number base system upon creation and conversion up to hexadecimal. Note This only shows the API that is for consumer use; hidden API is not listed.","title":"NumList"},{"location":"numlist/#class-properties","text":"","title":"Class Properties"},{"location":"numlist/#inherited-from-list","text":"Inline MaxDisplay ShowDataTypeContents is not inherited since the only datatype supported is numbers.","title":"Inherited from List"},{"location":"numlist/#constructors","text":"","title":"Constructors"},{"location":"numlist/#new","text":"Parameters ( table array, int base = 10) Creates a new NumList with the given array (filled with numbers only) and an optional base , which defaults to 10. For other bases, use strings in the array to preserve their numerical representation. If the strings are invalid (i.e. higher than base 16 or plain words), NumList will rasie an error something along the lines of NumList creation: an error occurred . However, despite the base given, the numbers will always be converted to base 10. --we will use this for future examples --binary inputs local MyNumList = NumList . new ({ '1010' , '1001' , '1000' , '0111' , '0110' , '0101' }, 2 ) --must include 2, else it will error! print ( MyNumList ) --NumList({10, 9, 8, 7, 6, 5})","title":"new"},{"location":"numlist/#fromnormal","text":"Parameters ( int count, number avg, number std) Creates a normalized distribution with count number of values and with the given mean of avg and standard deviation of std . Note Due to floating point errors that may occasionally arise, the average and standard deviation may be ever-so-slightly off (i.e. something like 5.0000000012 instead of 5 ).","title":"fromNormal"},{"location":"numlist/#fillwith","text":"Parameters ( int count, number value) Works just like List.fillWith except that the values must always be numerical.","title":"fillWith"},{"location":"numlist/#fromrandom","text":"Parameters ( number min, number max, int count) Creates count number of elements which are random numbers between the given min and max , which can be decimals. local MyNumList = NumList . fromRandom ( 0.1 , 0.55 , 5 ) print ( MyNumList ) --NumList({0.41, 0.18, 0.5, 0.44, 0.45})","title":"fromRandom"},{"location":"numlist/#fromrange","text":"Parameters ( number min, number max, number step = 1, int base = 10) Similar to Python's numpy.arange ; creates an array from min to max , incrementing by the optional step . The inputs for those three can be given in strings in case they are non-base 10 numbers. --array from 90-100 with inc 2 in the hexadecimal number system local MyNumList = NumList . fromRange ( '5A' , '64' , '2' , 16 ) print ( MyNumList ) --NumList({90, 92, 94, 96, 98, 100})","title":"fromRange"},{"location":"numlist/#linspace","text":"Parameters ( number min, number max, int count) Just like numpy.linspace ; it creates an array from min to max with the given count such that each number is spaced out by an event, automatically-calculated increment (unlike NumList.fromRange ). local MyNumList = NumList . linspace ( 1 , 10 , 5 ) print ( MyNumList ) --NumList({1, 3.25, 5.5, 7.75, 10}) Above, the increment is 2.25 (which can be calculated by (max - min) / (count - 1) ).","title":"linspace"},{"location":"numlist/#properties","text":"","title":"Properties"},{"location":"numlist/#inherited-from-list_1","text":"These properties are inherited from List and work the same way: Alias Length __type","title":"Inherited from List"},{"location":"numlist/#functions","text":"","title":"Functions"},{"location":"numlist/#getavg","text":"number Gets the average of the numbers, equivalent to doing NumList:GetSum() / NumList.Length .","title":"GetAvg"},{"location":"numlist/#getfivepointsummary","text":"table Gets the box-plot-related stats (minimum, first quartile, median, third quartile, and maximum) in a dictionary with the keys: * Min * Q1 * Median * Q3 * Max","title":"GetFivePointSummary"},{"location":"numlist/#getmad","text":"number Gets the mean absolute deviation of the NumList ; the length must be greater than 0, else an error will be raised.","title":"GetMAD"},{"location":"numlist/#getmax","text":"number Gets the maximum value from the NumList .","title":"GetMax"},{"location":"numlist/#getmedian","text":"number Gets the median of the NumList .","title":"GetMedian"},{"location":"numlist/#getmin","text":"number Gets the minimum value from the NumList .","title":"GetMin"},{"location":"numlist/#getmode","text":"table Gets the mode of the set and returns the values in a table (since multiple values can appear the same number of times). If every value appears exactly once in the set, the mode will be nil .","title":"GetMode"},{"location":"numlist/#getproduct","text":"number Simply gets the product of all the elements in the NumList .","title":"GetProduct"},{"location":"numlist/#getq1","text":"number Gets the first quartile of the set.","title":"GetQ1"},{"location":"numlist/#getq3","text":"number Gets the third quartile of the set.","title":"GetQ3"},{"location":"numlist/#getrange","text":"number Gets the range, the difference between the maximum and the minimum.","title":"GetRange"},{"location":"numlist/#getstats","text":"table Gets all the stats in a dictionary, with the keys: Min Q1 Median Q3 Max Range Sum Product Avg Std MAD Mode For Mode , the value will be \"None\" to represent nil because else the key will be non-existent.","title":"GetStats"},{"location":"numlist/#getstd","text":"number Gets the population standard deviation of the set of numbers; the length of the NumList must be greater than 1, else it will raise an error.","title":"GetStd"},{"location":"numlist/#getsum","text":"number Simply gets the sum of all the elements in the NumList .","title":"GetSum"},{"location":"numlist/#tobase","text":"table Parameters ( int base) Converts the current base-10 NumList values to the given base , which will be returned as a table ( not a NumList) with string values. Also works with decimals. local MyNumList = NumList . new ({ 90 , 92 , 94 , 96 , 98 , 100 }) print ( MyNumList : ToBase ( 16 )) --{\"5A\", \"5C\", \"5E\", \"60\", \"62\", \"64\"}","title":"ToBase"},{"location":"numlist/#inherited-from-list_2","text":"These functions are inherited from List and are also available with NumList (only with slight modifications to accept only numbers, for example): NumList:Append NumList:Clear NumList:Clone NumList:Count NumList:CountValues NumList:Destroy NumList:Empty NumList:Find NumList:Pairs NumList:Remove NumList:RemoveDuplicates NumList:Replace NumList:Reverse NumList:Select NumList:Sort NumList:Zip","title":"Inherited from List"},{"location":"numlist/#events","text":"","title":"Events"},{"location":"numlist/#inherited-from-list_3","text":"These events work the same as they do with List : Added Changed Removed","title":"Inherited from List"}]}